# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1U4DVNd7q9H8irv2KUoZDbgCGv2Q65KqS
"""

import numpy as np

print("Find Root of Equation using Bisection Method\n")

def f2(x):
  a = 10 * (x ** 3)
  b = 8 * (x ** 2)
  return a + b + 9

def bisection2(a, b, tolerance, ori_a, ori_b):
  # Rules for np.sign: If the value being passed is greater than 0,
  # it will return 1, otherwise -1.
  # Validate the sign must be different
  if np.sign(f2(a)) == np.sign(f2(b)):
    print(f"a = {a} and b = {b} not bound a root")
    return

  # Update value of c
  c = (a + b) / 2

  # It must be absolute because the value of 'c' might be negative.
  # If it's negative, it will always fall below the tolerance
  if(np.abs(f2(c)) < tolerance):
    print(f"root of the function = {c} with coordinates of x1 = {ori_a} and x2 = {ori_b}")
    return

  if(np.sign(f2(c)) == np.sign(f2(a))):
    bisection2(c, b, tolerance, ori_a, ori_b)
  elif(np.sign(f2(c)) == np.sign(f2(b))):
    bisection2(a, c, tolerance, ori_a, ori_b)

coordinates = [
  [3, 4],
  [-10, 17],
  [10, -15],
  [-2, 4],
  [12, -5],
  [-8, -13],
  [7, -21],
]

i = 0

for i in range(7):

  tolerance = 0.001
  print(f"{i + 1}. ", end="")
  bisection2(coordinates[i][0], coordinates[i][1], tolerance, coordinates[i][0], coordinates[i][1])